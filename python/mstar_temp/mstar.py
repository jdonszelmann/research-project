from __future__ import annotations

from itertools import product
from typing import Optional, List, Tuple, Set, Iterable, Iterator

from mapfmclient import MarkedLocation

from python.agent import Agent
from python.astar.no_solution import NoSolutionError
from python.coord import Coord
from python.mstar_temp.identifier import Identifier
from python.priority_queue.fast_contains import FastContainsPriorityQueue


class State:
    def __init__(self, identifier: Identifier):
        self.identifier = identifier
        self.collision_set = set()
        self.back_set = dict()

        self.parent = None

        self.cost = 1e6
        self.heuristic = None

    def __hash__(self):
        return hash(self.identifier)

    def copy(self) -> State:
        s = State(self.identifier)
        s.cost = self.cost
        s.heuristic = self.heuristic
        s.parent = self.parent
        s.collision_set = self.collision_set.copy()
        s.back_set = self.back_set.copy()
        return s

    @property
    def priority(self) -> int:
        return self.cost + self.heuristic

    @property
    def is_standard(self) -> bool:
        """
        Standard nodes are nodes which do not contain partial actions (as are generated by
        operator decomposition)
        :return: True if this state is standard.
        """
        return self.identifier.partial == self.identifier.actual

    def merge_collision_sets(self, other_collision_set):
        self.collision_set = self.collision_set.union(other_collision_set)

    def is_collision_subset(self, other_set):
        return other_set.issubset(self.collision_set)

    def add_back_set(self, state: State):
        assert isinstance(state, type(self))
        self.back_set[state.identifier] = state

    def get_back_set(self):
        return self.back_set.values()

    def backtrack(self, res: Optional[List[State]] = None) -> List[State]:
        if res is None:
            res: List[State] = []
        if self.parent is not None:
            self.parent.backtrack(res)

        res.append(self)

        return res

    def __eq__(self, other: State) -> bool:
        return self.identifier == other.identifier

    def __gt__(self, other: State) -> bool:
        return self.priority > other.priority

    def __ge__(self, other: State) -> bool:
        return self.priority >= other.priority

    def __lt__(self, other: State) -> bool:
        return self.priority < other.priority

    def __le__(self, other: State) -> bool:
        return self.priority <= other.priority


class StateCache:
    def __init__(self):
        self.cache = dict()
        # self.intermediate = use_intermediate_nodes

    def get(self, identifier: Identifier) -> State:
        if identifier in self.cache:
            return self.cache[identifier]
        else:
            self.cache[identifier] = State(identifier)
            return self.cache[identifier]


class MStar:
    def __init__(self,
                 starts: List[MarkedLocation],
                 ends: List[MarkedLocation],
                 expand_position,
                 get_next_joint_policy_position,
                 get_shortest_path_cost
                 ):
        """
        This class implements subdimensional expansion with a star as the search algorithm.
        It assumes the following functions which are external to the class:
            -- expand_position: returns the neighbouring vertices of a single position
            -- get_next_joint_policy_position: Returns the next vertex of a particular agents
                                        joint policy action
                                        where the joint policy is the shortest path action
                                        where there is no other agents.
            -- get_SIC: returns the sum of individual cost (individual
                        optimal path cost from vertex vk to vf)
        """
        assert len(starts) == len(ends), "start and end positions have to be of same length"

        self.starts = starts
        self.ends = ends
        self.v_len = len(starts)
        # self.f_e_kl = self.v_len * 1 #cost of traversing an edge
        self.expand_position = expand_position
        self.get_next_joint_policy_position = get_next_joint_policy_position
        self.heuristic_shortest_path_cost = get_shortest_path_cost
        self.state_cache = StateCache()

    def search(self, OD=True) -> List[State]:
        pq = FastContainsPriorityQueue()
        start_identifier = Identifier.from_marked_locations(self.starts)

        start_state = self.state_cache.get(start_identifier)
        start_state.cost = 0
        start_state.heuristic = self.heuristic(start_state.identifier)
        pq.enqueue(start_state)

        if OD:
            expand_function = self.expand_OD
        else:
            expand_function = self.expand_joint_actions

        while not pq.empty():
            curr = pq.dequeue()

            # TODO: matching
            if self.final_state(curr):
                return curr.backtrack()

            for new_identifier in expand_function(curr):
                # Intermediate states not part of back propagation
                # For standard states only
                new = self.state_cache.get(new_identifier)
                col = self.collisions(curr.identifier.actual, new.identifier.actual)

                if new.is_standard:
                    new.add_back_set(curr)
                    new.merge_collision_sets(col)
                    self.backprop(curr, new.collision_set, pq)
                if (len(col) == 0 or not new.is_standard) and curr.cost + self.get_move_cost(curr, new) < new.cost:
                    new.cost = curr.cost + self.get_move_cost(curr, new)
                    new.heuristic = self.heuristic(new.identifier)
                    new.parent = curr
                    pq.enqueue(new)

        raise NoSolutionError

    def backprop(self, v_k, c_l, pq):
        if v_k.is_standard:
            if not c_l.issubset(v_k.collision_set):
                v_k.merge_collision_sets(c_l)
                if not v_k in pq:
                    v_k.heuristic = self.heuristic(v_k.identifier)
                    pq.enqueue(v_k)
                for v_m in v_k.get_back_set():
                    self.backprop(v_m, v_k.collision_set, pq)

    def heuristic(self, identifier: Identifier):
        total_cost = 0
        for i, pos in enumerate(identifier.partial):
            # TODO: probably for OD
            # if pos == "_":
            #     total_cost += self.heuristic_shortest_path_cost(i, vertex_pos[i])
            # else:
            total_cost += self.heuristic_shortest_path_cost(i, pos)
        return total_cost

    @classmethod
    def collisions(cls, old_state: List[Agent], new_state: List[Agent]) -> Set[int]:
        """
        :param old_state: the parent state from which the new state was generated (used for edge constraints)
        :param new_state: the new state that is generated, about which we want to know if it contains collisions
        :return: A set of agent indices (TODO!)
        """

        assert len(old_state) == len(new_state)

        res = set()

        for a1 in range(len(old_state)):
            for a2 in range(min(a1, len(new_state))):
                if new_state[a1] == new_state[a2]:
                    res.add(a1)
                    res.add(a2)

                elif old_state[a1] == new_state[a2] and new_state[a1] == old_state[a2]:
                    res.add(a1)
                    res.add(a2)

        return res

    def final_state(self, state: State) -> bool:
        # implied by constraints on move
        # if self.has_double(state.agents):
        #     return False

        for agent in state.identifier.actual:
            if not self.on_final(agent):
                return False

        return True

    def on_final(self, agent: Agent) -> bool:
        for i in self.ends:
            if i.x == agent.x and i.y == agent.y and i.color == agent.color:
                return True

        return False

    def get_move_cost(self, old_state: State, new_state: State):
        """
        Cost of moving from old_state to new_state
        """
        # It is possible for old_state and new_state to both be standard nodes. Need to account for this in cost
        # Due to subdimensional expansion, expanded node neighbours are not always 1 apart.
        # eg. expanding a standard node where x agents follow individually optimal policies
        end = list(self.ends)
        if old_state.is_standard:
            if new_state.is_standard:
                cost = self.v_len
                # count number of transitions from goal to goal pos
                num_agents_stay_on_goal = 0
                for old_agent, new_agent in zip(old_state.identifier.partial, new_state.identifier.partial):
                    if self.on_final(old_agent) and self.on_final(new_agent):
                        num_agents_stay_on_goal += 1

                cost -= num_agents_stay_on_goal
                assert cost >= 0
            else:
                # vk should be root node of vn
                assert old_state.identifier.actual == new_state.identifier.actual
                cnt_vn = 0
                for g, new_agent, old_agent in zip(end, new_state.identifier.partial, old_state.identifier.partial):
                    if not new_agent == '_':
                        if new_agent == g and old_agent == g:  # if agent stayed on goal
                            cnt_vn += 0
                        else:
                            cnt_vn += 1
                cost = cnt_vn
        else:
            if new_state.is_standard:
                num_pos_canged = 0
                cost = 0
                for gp, old_agent, new_agent, pk_root in zip(end, old_state.identifier[0], new_state.identifier[0], old_state.identifier[1]):
                    if old_agent == '_':
                        assert not new_agent == "_"
                        num_pos_canged += 1
                        if new_agent == gp and pk_root == gp:
                            cost += 0
                        else:
                            cost += 1
                assert num_pos_canged == 1
            else:
                num_pos_canged = 0
                cost = 0
                for gp, old_agent, new_agent, pk_root in zip(end, old_state.identifier[0], new_state.identifier[0], old_state.identifier[1]):
                    if old_agent == '_' and not new_agent == "_":
                        num_pos_canged += 1
                        if new_agent == gp and pk_root == gp:
                            cost += 0
                        else:
                            cost += 1
                assert num_pos_canged == 1

        assert cost >= 0  # vn should always be of higher count
        return cost

    def expand_OD(self, v) -> Identifier:
        (inter_tup, vertex_pos_tup) = v.identifier
        collision_set = set()
        next_inter_tup = []  # list(inter_tup)
        # If standard node create next intermediate node base
        # else convert current inter_tup to list
        if "_" not in inter_tup:
            assert v.is_standard
            collision_set = v.collision_set
            for i, p in enumerate(inter_tup):
                if i in collision_set:
                    next_inter_tup.append("_")
                else:
                    n_pos = self.get_next_joint_policy_position(i, p, self.ends[i])
                    next_inter_tup.append(n_pos[-1])
        else:
            next_inter_tup = list(inter_tup)

        # Deterimine intermediate node level
        this_inter_level = None
        for i, p in enumerate(next_inter_tup):
            if p == '_':
                this_inter_level = i
                break

        all_next_inter_tup = []
        if this_inter_level is not None:
            # if not a standard vertex
            pos = vertex_pos_tup[this_inter_level]
            positions_taken = [p for p in next_inter_tup if p != '_']
            n_pos = self.expand_position(i, pos)
            valid_n_pos = [p for p in n_pos if not p in positions_taken]

            if len(valid_n_pos) == 0:
                return []
            for p in valid_n_pos:
                next_inter_tup[this_inter_level] = p
                all_next_inter_tup.append(tuple(next_inter_tup))
        else:
            all_next_inter_tup.append(tuple(next_inter_tup))
            assert not "_" in next_inter_tup  # should be standard node

        # Make v_id's:
        v_ids = []
        for inter_v in all_next_inter_tup:
            if not "_" in inter_v:
                v_ids.append((tuple(inter_v), tuple(inter_v)))
            else:
                v_ids.append((tuple(inter_v), vertex_pos_tup))

        return v_ids

    def expand_joint_actions(self, state: State) -> Iterable[Identifier]:
        assert state.is_standard, "used expand joint actions with non-standard node"

        all_positions = []
        collisions = state.collision_set

        for i, p in enumerate(state.identifier.actual):
            if i in collisions:
                all_positions.append(self.expand_position(i, p))
            else:
                all_positions.append(self.get_next_joint_policy_position(i, p))

        joint_positions = product(*all_positions)

        next_v_id = []
        for j_pos in joint_positions:
            j_pos: Tuple[Agent]
            next_v_id.append(Identifier(j_pos, j_pos))

        return next_v_id
